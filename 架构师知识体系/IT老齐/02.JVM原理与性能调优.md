# 深入理解Java虚拟机

感谢祖师爷`詹姆斯高斯林`，为我们提供了最好的虚拟机平台-**JVM**

## 一、JVM概述

### 1.1 跨平台开发的通用平台

> Java虚拟机，或称JVM，它为Java程序提供了一个统一的运行环境，从而实现“Write Once, Run Anywhere”。主要职责是加载、验证并运行Java字节码。

随着发展，JVM不再是Java独享的Moment，越来越多的语言开始在JVM上运行，使JVM逐渐演变成一个**跨平台开发的通用平台**。

* JVM本质上只关心`.class`的字节码文件，而不关心源代码是用什么语言编写的

![JVM不再是Java独享的Moment](https://img.geekyspace.cn/pictures/2024/image-20240620020158368.png)

以上各语言的特性：

| 语言      | 特性描述                   |
|---------|------------------------|
| Java    | 最流行的跨平台语言              |
| Kotlin  | Google官方支持的Android开发语言 |
| Groovy  | 敏捷开发脚本语言，与Java无缝集成     |
| Clojure | 并发编程语言，基于Lisp语言        |
| Scala   | Spark大数据处理的最佳选择        |

### 1.2 JVM发展过程与种类

只要通过`Oracle TCK`认证，任何人都可以开发自己的JVM，这也是为什么有这么多种JVM的原因

![JVM不是少数机构的特权](https://img.geekyspace.cn/pictures/2024/image-20240624025158387.png)

**武林盟主 HotSpot**
	* 1.3 至今默认VM
	*  最早是Logview公司设计，被sun收购
	* HotSpot同时支持解释器和编译器
	* Hotspot在程序响应速度和执行效率间寻找平衡
	* 只有Hotspot才有方法区（永久代）
主流JVM的介绍：

| JVM 类型             | 特点                                                                        | 优势               | 局限性                     |
| ------------------ | ------------------------------------------------------------------------- | ---------------- | ----------------------- |
| **Sun Classic VM** | - 最早的JVM<br>- 1.0 出现，1.4 淘汰<br>- 仅提供Java解释器<br>- 可外挂即时编译器                 | 高响应速度            | 解释器与编译器二选一              |
| **Exact VM**       | - 出现于1.2 版本<br>- 混合运行解释器与编译器                                              | 结合解释器与编译器的优势     | 仅支持Sun Solaris自家平台      |
| **==HotSpot VM==** | - 1.3 至今默认VM<br>- 同时支持解释器与编译器<br>- 独特的“方法区”（永久代）                          | 响应速度与执行效率平衡      | **方法区**内存管理问题（JDK 8中移除） |
| **JRockit VM**     | - 专注服务器端<br>- 不含解释器，只有编译器                                                 | 速度快，专为高性能服务器设计   | 不适合桌面应用，已停止开发           |
| **IBM J9 VM**      | - 通用型JVM，接近Hotspot<br>- 2017年开源为[OpenJ9](https://www.eclipse.org/openj9/) | 开源社区支持，针对IBM产品优化 | 主要优势在IBM产品上             |
| **Taobao VM**      | - 基于OpenJDK的Hotspot定制<br>- 针对淘宝特定应用场景优化                                   | 适应高并发、高流量需求      | 专用性强，不适合一般用途            |

### 1.3 SunJDK与OpenJDK 的异同

* **共同点：** 默认都使用 **HotSpot**
* **许可证与商用使用**：
    * Oracle/Sun JDK 基于[JRL](https://en.wikipedia.org/wiki/Java_Research_License)只允许个人研究
    * OpenJDK 基于[GPL](https://en.wikipedia.org/wiki/GNU_General_Public_License) v2 允许商用
* **功能差异：**
    * OpenJDK不包含Deployment部署功能
    * OpenJDK只包含JDK核心，Rhino/JAXP等组件需自行安装
    * 无法通过TCK测试，不能使用Java商标
    * Red Hat 致力补全，已通过TCK

### 1.4 JVM虚拟机的组成

请先查看完整的JVM架构图，以便对整体有个初步了解，接下来会进行详细的解释。

![jvm-framework](https://img.geekyspace.cn/pictures/2024/0082zybply1gc6fz21n8kj30u00wpn5v.jpg)

从整体上看，JVM 由三个不同的组件组成：

1. **类加载子系统（Class Loader SubSystem）**：主要负责将类`.class`加载到内存中
2. **运行时数据区（Runtime Data Area）**：管理JVM运行时所需的数据结构
   * 包括方法区、堆、栈、程序计数器、本地方法栈
3. **执行引擎（Execution Engine）**：负责执行字节码指令，将其转换为机器代码，供机器理解

![JVM三大组件](https://img.geekyspace.cn/pictures/2024/image-39.png)

---

第一个组件==**类加载过程**==分为三个阶段：加载、链接和初始化。

**1. 加载（Loading）**：将类的字节码文件加载到内存中，并生成 JVM 运行时的类表示
* **启动类加载器（Bootstrap Class Loader）：**
  * 负责加载Java的核心类库，如`java.lang`、`java.net`、`java.util`、`java.io`等
  * 这些类库位于`$JAVA_HOME/jre/lib`目录中，例如`rt.jar`
* **扩展类加载器（Extension Class Loader）：**
  * Bootstrap类加载器的子类，同时也是Application类加载器的父类。
  * 它负责加载位于`$JAVA_HOME/jre/lib/ext`目录中的Java标准库的扩展
* **系统类加载器（Application Class Loader）：**
  * Extension类加载器的子类，加载位于类路径上的类文件，默认情况下，类路径为应用程序的目录
  * 可通过添加命令行选项`-classpath`或`-cp`来修改类路径

**2. 链接（Linking）**：将类的二进制数据合并到JVM的运行时状态中，分为以下三个步骤：
- **验证（Verify）**：通过一组约束或规则检查`.class`文件的正确性，验证失败抛出`VerifyException`
- **准备（Prepare）**：为类或接口的静态字段分配内，存并设置默认初始值
- **解析（Resolve）**：将符号引用替换为常量池中存在的直接引用

**3. 初始化（Initialization）**：执行类的静态初始化块和静态变量的初始化

![类加载三个阶段](https://img.geekyspace.cn/pictures/2024/image-40.png)

---

第二个组件==**运行时数据区域**==内含有五个数据区域：

* 线程共享区：
  - **方法区（Method Area）**：存储已加载的类信息、常量池、静态变量和即时编译后的代码
  - **堆（Heap Area）**：用于动态分配对象实例和数组

* 线程隔离区：
  - **虚拟机栈（Virtual Machine Stack）**：存储局部变量、操作数栈、栈帧和方法调用信息
  - **程序计数器（PC寄存器，Program Counter Register）**：存储当前执行的字节码指令的地址
  - **本地方法栈（Native Method Stack）**：用于执行本地方法（非Java代码，如C或C++编写的代码）

![运行时数据区](https://img.geekyspace.cn/pictures/2024/image-32.png)

---

第三个组件==**执行引擎**==包含解释器、编译器和垃圾回收区：
* **解释器（Interpreter）**：逐条解释执行字节码指令，速度较慢，但实现简单
* **即时编译器（JIT Compiler，Just-In-Time Compiler）**：将热点字节码（经常执行的字节码）编译成机器码，以提高执行效率
* **垃圾回收器（Garbage Collector）**：自动管理和回收堆中的无用对象，防止内存泄漏

![执行引擎](https://img.geekyspace.cn/pictures/2024/image-33.png)

这些部分共同组成了 JVM 的核心功能，使得 Java 程序可以跨平台运行，并且具有良好的性能和安全性

---

**参考：**

- https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/
- https://pdai.tech/md/java/jvm/java-jvm-struct.html

## 二、字节码概述

### 2.1 字节码的组成结构

Java字节码是以类文件（`.class`文件）形式存储的。类文件结构复杂而有序，包含了详细的描述和指令，确保Java虚拟机可以正确执行字节码。以下是类文件的主要组成部分：

**1. 魔数（Magic Number）：**

* `.class`文件开头有一个4字节的魔数 `0xCAFEBABE`，用于标识文件类型

**2.版本号（Minor & Version Number）：**

* 紧跟魔数 `0xCAFEBABE` 之后，分为主/次版本号，各占用2个字节，指示该`.class`文件编译的Java版本

**3. 常量池（Constant Pool）**

* 常量池是一个表结构，由多个常量池条目组成，每个条目存储一种类型的常量或符号信息

  * **字面量常量**：存储字符串、整数、浮点数等字面量常量，支持字节码指令中的常量操作
  * **符号引用**：存储类名、字段名、方法名等符号信息，使JVM在运行时能够解析和引用这些符号
  * **类型描述**：存储字段和方法的类型描述符，帮助JVM在运行时进行类型检查和方法调用
  * **动态链接**：支持JVM在运行时进行动态链接，解析符号引用并将其转换为具体的内存地址

  ![常量池类型](https://img.geekyspace.cn/pictures/2024/image-20240704180550330.png)

**4. 访问标志（Access Flags）**

* 用于描述类、字段、方法等访问权限和特性的重要部分（如是否为public、abstract、final等）

**5.类索引、父类索引和接口索引集合**

- **类索引**：指向常量池中当前类的类描述符
- **父类索引**：指向常量池中父类的类描述符
- **接口索引集合**：指向常量池中所实现接口的描述符列表

**6. 字段表（Fields）**

* 包含类中声明字段，每个字段包括字段名、描述符（`Ljava/lang/String;`）、访问标志等

**7. 方法表（Methods）**

* 包含类中声明的方法，每个方法包括方法名、描述符`(Ljava/lang/String;)V`、访问标志等

**8. 属性表（Attributes）**

* 属性表包含类、字段、方法的额外信息，如注解、调试信息、源码文件名等。常见的属性包括：
    - **Code**：存储方法的字节码指令

    - **LineNumberTable**：存储源码行号与字节码指令的对应关系

    - **SourceFile**：指示生成该类文件的源文件名

### 2.2 查看字节码

**方案1：使用[WinHex](https://www.ghxi.com/winhex.html)(十六进制编辑器) 打开`.class`文件查看**

**方案2：使用javap命令查看字节码**

```shell
javap -v -l -c Example.class
```

```shell
$ javap -help
用法: javap <options> <classes>
其中, 可能的选项包括:
  -? -h --help -help               输出此帮助消息
  -version                         版本信息
  -v  -verbose                     输出附加信息
  -l                               输出行号和本地变量表
  -public                          仅显示公共类和成员
  -protected                       显示受保护的/公共类和成员
  -package                         显示程序包/受保护的/公共类
                                   和成员 (默认)
  -p  -private                     显示所有类和成员
  -c                               对代码进行反汇编
  -s                               输出内部类型签名
  -sysinfo                         显示正在处理的类的
                                   系统信息 (路径, 大小, 日期, MD5 散列)
  -constants                       显示最终常量
  --module <模块>, -m <模块>       指定包含要反汇编的类的模块
  --module-path <路径>             指定查找应用程序模块的位置
  --system <jdk>                   指定查找系统模块的位置
  --class-path <路径>              指定查找用户类文件的位置
  -classpath <路径>                指定查找用户类文件的位置
  -cp <路径>                       指定查找用户类文件的位置
  -bootclasspath <路径>            覆盖引导类文件的位置
```

**方案3：使用[IDEA jclasslib插件](https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer)查看**

* `JClassLib`是字节码阅读工具
* `JClassLib`可以独立运行
* `JClassLib`提供了Idea的插件支持

### 2.3 字节码指令

字节码指令是JVM执行的低级指令集合，由Java编译器将Java源代码编译后保存在`Method`描述中。由操作码和操作数组成，运行时JVM读取后将其翻译为各平台的底层指令。

* 操作码（`Opcode`）：一个字节（8位）的无符号整数，总数不超过256条，表示特定的指令
* 操作数（`Operands`）：零个或者多个，紧跟在操作码之后，提供执行指令所需的附加信息

**字节码指令分类：**

1. 加载与存储指令（例如 `aload_0` ， `istore` ）
2. 算术指令（例如 `ladd` ， `fcmpl` ）
3. 类型转换指令（例如 `i2b` ， `d2i` ）
4. 对象创建与访问指令（ `new` ， `putfield` ）
5. 操作数栈管理指令（例如 `swap` 、 `dup2` ）
6. 控制转移指令（例如 `ifeq` 、 `goto` ）
7. 方法调用和返回指令（例如 `invokespecial` ， `areturn` ）
8. 异常处理指令（例如 `athrow`）
9. 同步指令（例如 `monitorenter` ， `monitorexit` ）

**加载与存储指令：**

* 指令集前缀

  * `i`对 int 类型的数据操作

  * `I`对 long 类型的数据操作

  * `s`对 short 类型的数据操作

  * `b`对 byte 类型的数据操作

  * `c`对 char 类型的数据操作

  * `f`对 float 类型的数据操作

  * `d`对 double 类型的数据操作

  * `a`对 reference(引用)类型的数据操作

**字节码指令图：**

![字节码指令图](https://img.geekyspace.cn/pictures/2024/字节码指令图.png)

## 三、类加载子系统

### 3.1 类加载过程

[#1.4 JVM虚拟机的组成 ](#1.4 JVM虚拟机的组成) 中有讲到==类加载过程==分为三个阶段：加载、链接和初始化。

![类加载执行过程](https://img.geekyspace.cn/pictures/2024/image-20240709152505866.png)

### 3.2 三个阶段

![类加载三个阶段](https://img.geekyspace.cn/pictures/2024/image-40.png)

#### 加载（Loading）

1. **读取字节码二进制流：**从文件系统、JAR 包或网络读取类的字节码二进制流
2. **解析静态数据：**解析字节码，提取静态数据并存储在 JVM 的方法区中
3. **生成 `java.lang.Class` 对象：**将其放入堆中
4. **关联 `Class` 对象与方法区：**使 `Class` 对象成为访问方法区数据的入口
5. **触发父类加载：**确保父类在子类之前被加载

**示意图：**

![类加载示意图](https://img.geekyspace.cn/pictures/2024/image-20240710221949241.png)

#### 链接（Linking）

链接阶段包含三个子阶段：验证 (Verify)、准备 (Prepare) 和解析 (Resolve)。

**1. 验证（Verify）**：通过一组约束或规则检查`.class`文件的正确性，验证失败抛出`VerifyException`

* **文件格式验证**：确保类文件格式符合 JVM 规范（检查文件头`CAFEBABE`、版本号、常量池等）
* **元数据验证**：确保类中的元数据（字段、方法、接口）符合 JVM 规范（检查继承关系、访问修饰符等）
* **字节码验证**：确保字节码指令合法且不会导致 JVM 崩溃（检查操作码合法性、数据类型匹配、跳转指令有效性等）
* **符号引用验证**：确保符号引用（如类名、方法名、字段名）在解析时不会出错（验证引用是否存在且可访问）

**2. 准备（Prepare）**：为类或接口的静态字段分配内存并设置默认初始值

* **内存分配**：为所有静态字段分配内存空间（在方法区中）
* **初始值设置**：设置静态字段的初始值（基本类型如 int、float 初始化为 0、0.0 等，引用类型初始化为 `null`）

**3. 解析（Resolve）**：将符号引用替换为常量池中存在的直接引用

* **类或接口解析**：将符号引用的类或接口转换为直接引用（检查类是否已加载，未加载则触发类加载）
* **字段解析**：将符号引用的字段转换为直接引用（检查字段是否存在、是否可访问）
* **方法解析**：将符号引用的方法转换为直接引用（检查方法是否存在、是否可访问）
* **接口方法解析**：将符号引用的接口方法转换为直接引用（检查接口方法是否存在、是否可访问）

#### 初始化（Initialization）

**初始化阶段**：它负责执行类构造器方法 `<clinit>`；为类的静态变量赋值，并执行静态代码块。

* **静态变量赋值**：为类的静态变量赋值。如果有显示的赋值语句或静态初始化块，这些将在此阶段执行。

  ```java
  public class Example {
      static int a = 10; // 赋值语句
      static { b = 20; } // 静态初始化块
      static int b;
  }
  ```

* **执行静态代码块**：执行类中的静态代码块。

  ```java
  static {
      System.out.println("Static block executed");
  }
  ```

* **执行类构造器方法 `<clinit>`**：JVM 会自动为每个类生成一个 `<clinit>` 方法

  * 这个方法是所有静态变量赋值和静态代码块的集合，JVM 保证这个方法在类加载过程中只会被执行一次

  ```java
  public class Example {
      static int x = 3;
      static int y;
      static {
          y = x * 2;
      }
      // 等价于
      // <clinit> 方法内容:
      // static int x = 3;
      // static int y;
      // y = x * 2;
  }
  ```

**注意事项**：

- 初始化阶段是类加载的最后一步，只有在该类需要被主动使用时才会进行初始化，包括以下情况：
  - 使用 `new` 关键字创建对象
  - 调用反射 API，如 `Class.forName`
  - 子类加载时会同时触发父类的加载
  - JVM 启动时加载包含 `main` 方法的主类
  - 通过 `invokedynamic` 指令支持动态类型语言（参考 [JDK 1.7 的动态类型语言支持](https://www.infoq.cn/article/jdk-dynamically-typed-language/)）

- **类初始化是线程安全的**：JVM 会确保一个类的初始化方法 `<clinit>` 在多线程环境下被正确同步
- **接口的静态变量不会触发初始化**：只有在访问静态变量或静态代码块时才会触发初始化
- **使用 `-XX:+TraceClassLoading` 查看类加载过程**：在运行时添加该参数，可以查看 JVM 的类加载过程

### 3.3 类加载器种类

如图所示：类加载器的关系是上下级，而非继承关系

![Java中的ClassLoader](https://img.geekyspace.cn/pictures/2024/image-20240711025103643.png)

**1. 启动类加载器（Bootstrap ClassLoader）**

* **实现**：用原生代码（通常是 C/C++）实现
* **作用**：加载 Java 核心类库（如 `rt.jar`、`resources.jar`）
* **加载路径**：`${JAVA_HOME}/jre/lib` 目录和 `${sun.boot.class.path}` 路径下的 jar
* **特点**：基于沙箱机制，只加载 `java`、`javax`、`sun` 包开头的类

**2. 扩展类加载器（Extension ClassLoader）**

* **实现**：由 Java 编写，是 `sun.misc.Launcher$ExtClassLoader` 的实例
* **上级加载器**：启动类加载器
* **作用**：加载 `${JAVA_HOME}/jre/lib/ext` 目录下的类库
* **特点**：用户开发的 Jar 放入该目录会被加载

**3. 应用程序类加载器（Application ClassLoader）**

* **实现**：由 Java 编写，是 `sun.misc.Launcher$AppClassLoader` 的实例
* **上级加载器**：扩展类加载器
* **作用**：加载 classpath 下的应用程序类库
* **特点**：默认的类加载器，绝大多数类由它加载

**4. 自定义类加载器（Custom ClassLoader）**

* **实现**：用户可根据需求实现自己的类加载器
* **方法**：继承 `java.lang.ClassLoader` 类，并覆盖 `findClass` 方法
* **作用**：从任意位置加载类，如网络、数据库、加密文件等

**类加载器代码示例**

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Application ClassLoader: " + Main.class.getClassLoader());
        System.out.println("Extension ClassLoader: " + javax.crypto.Cipher.class.getClassLoader());
        System.out.println("Bootstrap ClassLoader: " + String.class.getClassLoader());
    }
}
```

输出示例：

```shell
Application ClassLoader: sun.misc.Launcher$AppClassLoader@yyyyyy
Extension ClassLoader: sun.misc.Launcher$ExtClassLoader@xxxxxx
Bootstrap ClassLoader: null
```

### 3.4 双亲委派模型

双亲委派模型是 Java 类加载机制的一种设计模式，用于确保 Java 类加载的安全性和一致性。

其核心思想是：当一个类加载器接收到类加载请求时，首先将请求委派给父类加载器进行加载，只有当父类加载器无法加载该类时，子类加载器才会尝试加载。

**优点：**

- **安全性**：通过沙箱机制，防止核心类库被恶意或意外篡改
- **一致性**：确保同一个类在整个 JVM 中只有一个加载实例

## 四、运行时数据区域

![运行时数据区](https://img.geekyspace.cn/pictures/2024/image-32.png)

* 线程共享区：
  * **堆**：主要存储对象，作为方法区访问的入口
  * **方法区**：存储类/方法/字段等定义（元）数据
    - 运行时常量区：保存常量static数据
* 线程隔离区：

  - **程序计数器**：存储线程执行位置

  - **虚拟机栈**：存储Java方法调用与执行过程的数据

  - **本地方法栈**：存储本地方法的执行数据

### 4.1 程序计数器

**程序计数器（PC寄存器）：** 

是一个小的内存区域，每个线程私有，指示当前线程所执行的字节码指令的地址。

**作用：**

1. **存储字节码指令地址**

   * 执行`Java`方法时，程序计数器保存当前正在执行的字节码指令的地址

   * 执行`Native`方法时，程序计数器的值未定义（Undefined）

2. **在线程上下文切换：**

   * 保存并恢复线程的执行位置，确保线程切换后能从正确位置继续执行

   ![程序计数器-保存和恢复执行位置](https://img.geekyspace.cn/pictures/2024/202407120144854.png)

### 4.2 虚拟机栈

 虚拟机栈是线程私有的内存区域，其生命周期与线程相同。它描述了**方法执行的内存模型**。当方法被执行时，JVM 会为该方法同步创建一个==栈帧（Stack Frame）==。

* 用于存储局部变量、操作数栈、动态链接、方法出口等信息
* 每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程

![虚拟机栈](https://img.geekyspace.cn/pictures/2024/202407120222400.png)

启动 Java 应用程序时，可以通过命令行参数 `-Xss` 设置栈的大小，建议设置512k：

```
java -Xss<size>[k|m|g] YourMainClass
```

**局部变量表（Local Variable Table）**

局部变量表是方法执行时==用于存储方法参数和局部变量==的一块内存空间。

* 每个方法都有自己独立的局部变量表，大小在编译期确定
* 以变量槽（Slot）为最小单位
  * 索引从 0 开始，第一个位置通常用于存储`this`引用（非静态方法）
  * 可以存储基本数据类型（如 boolean、byte、char、short、int、float）或对象引用（reference类型）
  * 其中 64 位长度的双精度类型（如 long 和 double）会占用两个槽

**操作数栈（Operand Stack）**

操作数栈是JVM中的一个后进先出（LIFO）结构，用于方法执行时==存储执行指令产生中间结果==。

* 操作数栈在方法调用时被分配，方法中的指令会将数据推入或弹出栈

* 操作数栈的大小在编译期确定，栈的每个元素可以是基本数据类型或引用类型
* 在字节码指令执行过程中，操作数栈会不断变化，以支持各种操作，如算术运算、方法调用等

**动态链接（Dynamic Linking）**

动态链接是指在方法调用时，==将符号引用转换为直接引用的过程==。

* JVM在方法调用时，会根据字节码中的符号引用查找实际的方法或字段，并将其转换为运行时的直接引用
* 这种机制允许类的动态加载和链接，使得程序可以在运行时进行类的替换和升级

**方法返回地址(Return Address)**

方法返回地址是指==方法调用后返回位置的地址==。

* 这种机制确保方法调用后的控制流能够正确返回到调用者，支持复杂的程序逻辑和嵌套方法调用

* 返回地址通常存储在操作数栈或局部变量表中，具体存储位置取决于调用指令的实现

### 4.3 本地方法栈

本地方法栈（Native Method Stack）与虚拟机栈功能非常相似，但它们的区别在于服务的对象不同。

* 虚拟机栈为虚拟机执行Java方法（字节码）服务
* 本地方法栈则为虚拟机执行本地（Native）方法服务
* Sun HotSpot 虚拟机把本地方法栈和虚拟机栈合二为一

### 4.4 Java堆

Java堆（Java Heap）是虚拟机管理的内存中最大的一块，线程共享，并在虚拟机启动时创建。它的唯一目的是存放对象实例，所有的对象实例以及数组都在堆上分配。

* 堆内存在物理上可能是分散的，但在逻辑上是连续的
* 堆中包含线程私有的缓冲区（TLAB，Thread-Local Allocation Buffer），用于提高JVM的并发处理效率

**堆内存结构图**

![堆内存模型](https://img.geekyspace.cn/pictures/2024/202407172004168.png)

**新生代 (Young Generation)**：

新生代是Java堆内存的一部分，用来存放新创建的对象。大部分新创建的对象在这里被分配内存。当新生代的内存空间被填满时，会触发一次Minor GC（小型垃圾回收），来清理无用的对象并腾出空间。新生代进一步划分为三个区域：Eden空间和两个Survivor空间（通常称为S0和S1）。

**老年代 (Old Generation)**

老年代是Java堆内存中存放生命周期较长对象的区域。当对象在新生代经过多次垃圾回收（通常是Minor GC）仍然存活，或者其大小超过了新生代的阈值时，会被移到老年代。老年代的垃圾回收（Major GC或Full GC）相对较少，但一旦发生，会比Minor GC耗时更多。

**元空间 (Metaspace)**

元空间是JDK 8及之后版本用来替代永久代（PermGen）的内存区域。它位于堆外内存，用于存放类的元数据，如类的名称、方法、字段等。与永久代不同，元空间的大小可以动态调整，几乎不需要频繁垃圾回收。元空间主要用来存储JVM加载的类信息，降低了类加载和卸载对GC的影响。

**参考：**

* https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java

### 4.5 方法区

方法区是JVM存储类和接口定义的共享数据区，在JVM启动时创建，退出时销毁。用于存储类信息、常量、静态变量（1.6版本前）、JIT 即时编译后的代码。

**永久代 & 元空间**

* JDK 1.7及之前称为==永久代（Permanent Generation）==
  * 堆的逻辑部分，有固定的大小，存储类加载器加载的类信息、常量池等
* JDK 1.8及之后称为==元空间（Metaspace）==
  * 元空间不再使用堆内存，而是使用本地内存，动态调整大小
  * 减少了内存溢出的风险，提高了内存管理的灵活性和效率

**设置元空间**

*  `-XX:MetaspaceSize` 
*  `-XX:MaxMetaspaceSize` 

### 4.6 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### VisualVM安装使用

官网地址: https://visualvm.github.io/

* IDEA 集成：[VisualVM Launcher](https://plugins.jetbrains.com/plugin/7115-visualvm-launcher/versions)

* Github开源翻译助手：[VVM-Translator](https://github.com/zedoCN/VVM-Translator)

* 安装插件VisualVM GC

