---
title: 版本控制工具Git
shortTitle: 
description: 
icon: 
cover: 
author: 流浪码客
isOriginal: true
sticky: false
star: false
date: 2025-04-21
category: 工程协作
tags:
  - Git
---
# 版本控制工具Git（README）
[Git官网](https://git-scm.com/)
[IDEA中高效使用Git](https://www.jetbrains.com/help/idea/using-git-integration.html)

> **Git** 是一个<u>分布式</u>版本控制系统，用于跟踪文件的更改，特别是源代码文件的更改。它由 **Linus Torvalds** 于 2005 年开发，最初是为了支持 **Linux 内核开发**。
## 起步
### 什么是“版本控制”？
版本控制是一种管理和跟踪文件变更的系统，允许多个用户协作开发并记录文件历史，便于回滚、合并和解决冲突。
### 版本控制系统（VCS）的发展
1. **本地版本控制系统 (Local Version Control System)**：
	只在本地计算机上管理文件版本，通常通过简单的目录或文件副本来保存文件的不同版本。例如： `RCS`。
2. **集中化版本控制系统 (Centralized Version Control System, CVCS)**：
	所有版本数据存储在中央服务器上，用户通过客户端访问和提交文件的变更。缺点是如果中央服务器出现问题，可能会导致无法访问历史版本。例如：`CVS`、`Subversion (SVN)`、`Perforce`。
3. **分布式版本控制系统 (Distributed Version Control System, DVCS)**：
   每个用户都有完整的版本历史库，允许脱机工作，并且可以将本地修改推送到中央仓库或其他用户的仓库。常见的有`Git`、`Mercurial`。
### Git 发展简史
1. **1991-2002年**：Linux 内核开发团队花费大量时间在提交补丁和保存归档上，管理工作繁琐。
2. **2002年**：Linux 内核团队使用 **BitKeeper** 版本控制系统，但因商业合作结束，失去免费使用 BitKeeper 的权限。
3. **2005年**：Linus Torvalds 不满意 BitKeeper，决定开发 **Git**，并设定了高效、分布式、支持非线性开发等目标。
4. **2005年4月**：Linus 发布了 Git 的第一个版本，初步实现了分布式版本控制的功能。
5.  **2005年后期**：Git 逐步被优化，加入了更强大的功能，如分支管理、合并、标签、历史查询等。
6. **2008年**：Git 被 **GitHub** 所推广，成为开源项目的首选版本控制系统，极大地推动了其普及。
7. **2010年后**：Git 成为全球开发者的主流工具，广泛应用于开源项目和企业开发。
### Git 基础
1. **直接记录快照，而非差异比较**：
	* Git 通过保存文件的完整快照来记录版本，而不是保存文件间的差异。
	* Git 对待数据更像是一个**快照流**。
2. **近乎所有操作都是本地执行**：
	* Git 在本地执行几乎所有操作，不需要连接到远程仓库。
	* 赋予了离线工作的能力。
3. **Git 保证完整性**：
	* Git 使用 SHA-1 哈希算法确保数据的完整性，保证每个版本的唯一性。
4. **Git 一般只添加数据**：
	* Git 在每次提交时通常只增加新的数据，而不覆盖已有数据，确保数据历史的连续性。
5. **三种状态**：
	*  文件有三种状态：**已提交（committed）**、**已修改（modified）**、**已暂存（staged）**。
	* 由三种状态引入了 Git 项目的**三个工作区域**：
		* **Git 仓库（Repository）**：
			* 存储提交的版本和历史记录，通常位于 `.git` 目录中。
			* 文件在提交（`git commit`）时从暂存区转移到仓库，成为项目历史的一部分。
		* **工作目录（Working Directory）**：
			* 你实际操作的文件目录，包含当前的文件状态，可以进行修改。
			* 文件的变化会使得文件处于 **已修改（Modified）** 状态。
		* **暂存区域（Staging Area 或 Index）**：
			* 暂存区域是一个临时区域，保存将要提交到 Git 仓库的文件修改。
			* 使用 `git add` 命令将文件的修改添加到暂存区域。
			* 在执行 `git commit` 命令后，暂存区域的内容会被提交到 Git 仓库。
## 安装 Git
### 在 Linux 上安装
**Debian/Ubuntu**
```shell
sudo apt-get install git
```
**Fedora**
```shell
sudo yum install git
```
要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 http://gitscm.com/download/linux。
### 在 Mac 上安装
**Homebrew**
* Git官网MacOS推荐使用Homebrew安装
	```shell
	brew install git
	```
**Xcode Command Line Tools**
* 如果你的系统没有安装过 **Xcode Command Line Tools**，在安装 **Homebrew** 过程中，会自动提示你安装 Xcode Command Line Tools。
* 这个工具包包含了许多开发者工具，**Git** 是其中的一部分。
* 要了解更多安装选项，请访问 [Git 官网 Mac 安装页面](https://git-scm.com/downloads/mac)。
### 在 Windows 上安装
**官网版本安装**
* 访问 [Git 官网下载页面](https://git-scm.com/downloads/win)，选择你操作系统的版本，通常是 `64-bit Git for Windows Setup`。
**Git for Windows**
* 也叫做`msysGit`，和 Git 是分别独立的项目；
* 更多信息请访问 https://gitforwindows.org/ 。
**GitHub Desktop**
* 通过安装GitHub Desktop程序，轻松体验 Git。
* 官网号称终极GUI Git客户端，用于简化并增强你的本地代码管理流程。
* 网址为 https://github.com/apps/desktop ，支持Mac版。
## 初次运行 Git 前的配置
Git 配置有三个层级，它们的优先级**从低到高**依次是：
1. **系统级配置** (`/etc/gitconfig`): 
	* 对系统上的所有用户和所有仓库有效，通用配置
	* 使用 `git config --system` 配置
2. **用户级配置** (`~/.gitconfig` 或 `~/.config/git/config`): 
	* 只针对当前用户
	* 使用 `git config --global` 配置
3. **仓库级配置** (`.git/config`): 
	* 仅对当前 Git 仓库有效
	* 使用 `git config --local` 配置
### 用户信息
安装完 Git 应该做的第一件事就是设置你的**用户名称**与**邮件地址**。
```shell
git config --global user.name "你的用户名"
git config --global user.email "你的邮箱"
```
* 使用 `--global` 选项后，只需要全局配置一次；针对特定项目配置，无需 `--global` 选项。
### 文本编辑器
将 `emacs` 设置为 Git 的默认文本编辑器
```shell
git config --global core.editor emacs
```
将 `VS Code` 设置为 Git 的默认文本编辑器
```shell
git config --global core.editor "code --wait"
```
### 检查配置信息
`git config --list` 命令会列出当前 Git 配置的所有项，包括全局和本地配置。
```shell
$ git config --list
credential.helper=osxkeychain     # 使用 macOS Keychain 管理 Git 凭证
init.defaultbranch=main           # 初始化 Git 仓库时，默认主分支为 'main'
user.name=joeljhou                # Git 提交时使用的用户名
user.email=joeljhou336@gmail.com  # Git 提交时使用的邮箱地址
core.ignorecase=false             # 文件名区分大小写，默认值 false
```
### 获取帮助
若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：
```shell
$ git help <verb> 
$ git <verb> --help 
$ man git-<verb>
```
例如，要想获得 config 命令的手册，执行
```shell
$ git help config
```
## Git 基础（命令篇）
#### `git init`：初始化仓库
```shell
$ git init
# 指定初始分支名 main, 较老的Git版本中默认是master
$ git init -b main
```
#### `git clone`：克隆远程仓库
```shell
git clone <repository-url>
```
#### `git add`：添加修改到暂存区
```shell
# 添加文件/夹，多个使用“空格”隔开
$ git add <file>...
# 添加所有文件（包括新建、修改、删除）
$ git add .
```
注意：运行了`git add`之后又作了修订的文件，需要重新运行`git add` 把最新版本重新暂存起来。
#### `git commit`：提交更新
```shell
$ git commit -m "提交更新"
# 给 git commit 加上 -a 选项
# Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤
$ git commit -a -m "跳过使用暂存区域"
```
#### `git status`：文件状态
查看当前 Git 仓库中文件的状态，了解哪些更改已暂存、哪些尚未提交。
1. **✅干净的工作目录：`nothing to commit, working tree clean`**
	* 没有任何改动，工作区和暂存区一致
2. **📦已暂存的更改：`Changes to be committed`**
	* `new file:` 新增文件并已暂存
	* `modified:` 文件内容有修改并已暂存
	* `deleted:` 文件已被删除并暂存
3. **📝有文件被修改但未暂存：`Changes not staged for commit`**
	- `modified:` 文件被修改但未暂存
	* `deleted:` 文件被删除但未暂存
4. **🆕未追踪文件：`Untracked files`**
	* 文件是新添加的，但 Git 尚未跟踪（未使用 `git add`）
#### `git status -s`：状态简览
相比 `git status` 的详细输出，`git status -s`（或 `--short`）提供更**紧凑**的状态摘要，适合快速查看当前变更
**示例：**
```shell
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
**速记：**
* 左边代表已暂存，右边代表已修改；
*  `M`是修改，`A`是添加，`??`是未追踪。
#### `.gitignore`：忽略文件
 ，格式规范如下：
* **空行和以 `#` 开头的行**：表示注释，会被 Git 忽略。
* **使用 glob 模式匹配文件路径**，类似简化版的正则表达式：
	* `*`：匹配任意数量的任意字符
	*  `?`：匹配单个任意字符
	* `[abc]`：匹配方括号中列出的任意一个字符
	* `[0-9]`：匹配指定范围内的字符（0~9）
	*  `**`：匹配任意中间路径，比如 `a/**/z` 可匹配 `a/z`、`a/b/z`、`a/b/c/z` 等
* **特殊前缀符号说明**
	*  `/` 开头：表示从仓库根目录开始匹配
	* `/` 结尾：表示匹配目录
	* `!` 开头：表示“取反”，即要忽略指定模式以外的文件或目录
**实际示例解析**
```shell
# 忽略所有 .a 文件
*.a
# 但要保留 lib.a（即使上面忽略了 .a 文件）
!lib.a
# 只忽略仓库根目录下的 TODO 文件
/TODO
# 忽略 build/ 目录及其中所有内容
build/
# 忽略 doc 目录下的 notes.txt 文件，但不忽略其他子目录下的 txt 文件
doc/*.txt
# 忽略 doc 目录下所有子目录中的 pdf 文件
doc/**/*.pdf
```

> GitHub 有一个收集了各种语言和框架的 `.gitignore` 模板库，可以从这里查找并使用符合自己项目的配置：  
👉 [https://github.com/github/gitignore](https://github.com/github/gitignore)
#### `git diff`：比较差异
用于比较 Git 各个区域（工作区、暂存区、提交记录）之间的差异，帮助开发者在提交前精准掌握代码变更。
**📌 常用对比场景与命令**

| 命令                             | 对比范围                                                   |
| ------------------------------ | ------------------------------------------------------ |
| `git diff`                     | 🧩 工作区 vs 📦 暂存区                                       |
| `git diff --cached`            | 📦 暂存区 vs 最新提交（HEAD）                                   |
| `git diff --staged`            | 📌 同上                                                  |
| `git diff HEAD`                | 🧩 工作区（含暂存+未暂存） vs HEAD                                |
| `git diff <commit>`            | 🕓 指定提交 vs 当前工作区                                       |
| `git diff <commit1> <commit2>` | 🕓 提交1 vs 提交2                                          |
| `git difftool`                 | 使用图形化工具查看差异，支持 `meld`、`vimdiff`、`Beyond` `Compare` 等工具 |
| `git difftool --tool-help`     | 查看系统支持哪些 Git Diff 插件                                   |
#### `git rm`：移除文件
 1. 从工作区移除文件 (`rm <file>`)
	* `git status`
		* **📝有文件被修改但未暂存：`Changes not staged for commit`**
			* `deleted:` 文件被删除但未暂存
	* 执行 `git add <file>`，将删除操作加入暂存区。
 2. **从工作区和暂存区移除文件 (`git rm <file>`)**
	* 等同于上述步骤
	*  `git status`
		* **📦已暂存的更改：`Changes to be committed`**
			* `deleted:` 文件已被删除并暂存
3. 仅从暂存区移除文件 (`git rm --cached <file>`)
	* 仅从暂存区删除，保留工作区内容。
**支持 Glob 模式**
* 允许使用通配符来匹配文件。
* **示例**：
	* `git rm –r *`
		* 递归删除整个目录中的所有子目录和文件
	* `git rm log/\*.log`
		* 删除 log/ 目录下扩展名为 .log 的所有文件
		* 如果没有反斜杠，Shell 会先将 `*.log` 展开成实际的文件列表
	* `git rm \*~`
		* 删除以 ~ 结尾的所有文件
		* **反斜杠作用**，避免Shell 将 `*~` 展开成所有符合该模式的文件，再传递给 `git rm`。
	* `git rm -r 'docs/*.md'`
		* 递归地删除 `docs` 目录下所有扩展名为 `.md` 的文件
#### `git mv`：移动文件
如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。
```shell
$ git mv README.md README
$ git status             
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    README.md -> README
```
相当于运行了下面三条命令：
```shell
$ mv README.md README
$ git rm README.md
$ git add README
```
#### `git log`：查看提交历史


#### `git push`：将提交推送到远程仓库
#### `git pull`：拉取远程仓库更新并合并
#### `git fetch`：获取远程更新（不自动合并）
#### `git branch`：查看和管理本地分支
#### `git checkout`：切换分支 / 恢复文件
#### `git switch`（推荐用法，替代部分 checkout）
#### `git merge`：合并分支
#### `git rebase`：变基（整理提交历史）
#### `git stash`：临时保存工作进度
#### `git tag`：创建和管理标签
#### `git reset`：重置提交或暂存区状态

#### `git remote`：管理远程仓库地址


### 文件状态变化周期
工作目录下的每一个文件都不外乎这两种状态：
1. **已跟踪文件**：
	* 即被版本控制的文件
	* 工作一段时间后，这些文件可能会处于以下几种状态：
		* **未修改**：文件内容自上次提交以来没有变化，保留在当前版本中。
		* **已修改**：文件的内容有变化，但这些修改还未被加入暂存区。
		* **已暂存**：文件修改后已经被添加到暂存区，准备在下次提交时记录这些变动。
2. **未跟踪文件**：
	* 未被版本控制，或忽略的文件
	* 通过`git add <filename>`可以将未跟踪文件添加到暂存区，纳入版本控制。
**Git文件的状态变化周期**
![文件的状态变化周期](http://img.geekyspace.cn/pictures/2025/20250502004429356.png)

### 检查当前文件状态

1. **暂存已修改文件（`Changes not staged for commit`）**
	* 现在我们来修改一个已被跟踪的文件。
	```shell
	$ echo '贡献' > README
	$ git status
	On branch main
	Changes not staged for commit:
	  (use "git add <file>..." to update what will be committed)
	  (use "git restore <file>..." to discard changes in working directory)
		modified:   README
	
	no changes added to commit (use "git add" and/or "git commit -a")
	```
	这表示：
	* 当前在 `main` 分支上。
	* `README` 文件已经被 Git 跟踪（因为之前用 `git add` 添加过），但现在它被修改了。
	* 修改后的文件 **还没有被加入暂存区**，也就是说这些更改不会包含在下一次提交中，除非你再次使用 `git add README`。
	* 可以使用以下命令进行操作：
		* `git add README`：将修改后的文件添加到暂存区，准备提交。
		* `git restore README`：撤销对 `README` 的修改，恢复到上一次提交的状态。




## Git 分支管理