---
title: 版本控制工具Git
shortTitle: 
description: 
icon: 
cover: 
author: 流浪码客
isOriginal: true
sticky: false
star: false
date: 2025-04-21
category: 工程协作
tags:
  - Git
---
# 版本控制工具Git（README）
[Git官网](https://git-scm.com/)
[IDEA中高效使用Git](https://www.jetbrains.com/help/idea/using-git-integration.html)

> **Git** 是一个<u>分布式</u>版本控制系统，用于跟踪文件的更改，特别是源代码文件的更改。它由 **Linus Torvalds** 于 2005 年开发，最初是为了支持 **Linux 内核开发**。
## 起步
### 什么是“版本控制”？
版本控制是一种管理和跟踪文件变更的系统，允许多个用户协作开发并记录文件历史，便于回滚、合并和解决冲突。
### 版本控制系统（VCS）的发展
1. **本地版本控制系统 (Local Version Control System)**：
	只在本地计算机上管理文件版本，通常通过简单的目录或文件副本来保存文件的不同版本。例如： `RCS`。
2. **集中化版本控制系统 (Centralized Version Control System, CVCS)**：
	所有版本数据存储在中央服务器上，用户通过客户端访问和提交文件的变更。缺点是如果中央服务器出现问题，可能会导致无法访问历史版本。例如：`CVS`、`Subversion (SVN)`、`Perforce`。
3. **分布式版本控制系统 (Distributed Version Control System, DVCS)**：
   每个用户都有完整的版本历史库，允许脱机工作，并且可以将本地修改推送到中央仓库或其他用户的仓库。常见的有`Git`、`Mercurial`。
### Git 发展简史
1. **1991-2002年**：Linux 内核开发团队花费大量时间在提交补丁和保存归档上，管理工作繁琐。
2. **2002年**：Linux 内核团队使用 **BitKeeper** 版本控制系统，但因商业合作结束，失去免费使用 BitKeeper 的权限。
3. **2005年**：Linus Torvalds 不满意 BitKeeper，决定开发 **Git**，并设定了高效、分布式、支持非线性开发等目标。
4. **2005年4月**：Linus 发布了 Git 的第一个版本，初步实现了分布式版本控制的功能。
5.  **2005年后期**：Git 逐步被优化，加入了更强大的功能，如分支管理、合并、标签、历史查询等。
6. **2008年**：Git 被 **GitHub** 所推广，成为开源项目的首选版本控制系统，极大地推动了其普及。
7. **2010年后**：Git 成为全球开发者的主流工具，广泛应用于开源项目和企业开发。
### Git 基础
1. **直接记录快照，而非差异比较**：
	* Git 通过保存文件的完整快照来记录版本，而不是保存文件间的差异。
	* Git 对待数据更像是一个**快照流**。
2. **近乎所有操作都是本地执行**：
	* Git 在本地执行几乎所有操作，不需要连接到远程仓库。
	* 赋予了离线工作的能力。
3. **Git 保证完整性**：
	* Git 使用 SHA-1 哈希算法确保数据的完整性，保证每个版本的唯一性。
4. **Git 一般只添加数据**：
	* Git 在每次提交时通常只增加新的数据，而不覆盖已有数据，确保数据历史的连续性。
5. **三种状态**：
	*  文件有三种状态：**已提交（committed）**、**已修改（modified）**、**已暂存（staged）**。
	* 由三种状态引入了 Git 项目的**三个工作区域**：
		* **Git 仓库（Repository）**：
			* 存储提交的版本和历史记录，通常位于 `.git` 目录中。
			* 文件在提交（`git commit`）时从暂存区转移到仓库，成为项目历史的一部分。
		* **工作目录（Working Directory）**：
			* 你实际操作的文件目录，包含当前的文件状态，可以进行修改。
			* 文件的变化会使得文件处于 **已修改（Modified）** 状态。
		* **暂存区域（Staging Area 或 Index）**：
			* 暂存区域是一个临时区域，保存将要提交到 Git 仓库的文件修改。
			* 使用 `git add` 命令将文件的修改添加到暂存区域。
			* 在执行 `git commit` 命令后，暂存区域的内容会被提交到 Git 仓库。
## 安装 Git
### 在 Linux 上安装
**Debian/Ubuntu**
```shell
sudo apt-get install git
```
**Fedora**
```shell
sudo yum install git
```
要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 http://gitscm.com/download/linux。
### 在 Mac 上安装
**Homebrew**
* Git官网MacOS推荐使用Homebrew安装
	```shell
	brew install git
	```
**Xcode Command Line Tools**
* 如果你的系统没有安装过 **Xcode Command Line Tools**，在安装 **Homebrew** 过程中，会自动提示你安装 Xcode Command Line Tools。
* 这个工具包包含了许多开发者工具，**Git** 是其中的一部分。
* 要了解更多安装选项，请访问 [Git 官网 Mac 安装页面](https://git-scm.com/downloads/mac)。
### 在 Windows 上安装
**官网版本安装**
* 访问 [Git 官网下载页面](https://git-scm.com/downloads/win)，选择你操作系统的版本，通常是 `64-bit Git for Windows Setup`。
**Git for Windows**
* 也叫做`msysGit`，和 Git 是分别独立的项目；
* 更多信息请访问 https://gitforwindows.org/ 。
**GitHub Desktop**
* 通过安装GitHub Desktop程序，轻松体验 Git。
* 官网号称终极GUI Git客户端，用于简化并增强你的本地代码管理流程。
* 网址为 https://github.com/apps/desktop ，支持Mac版。
## 初次运行 Git 前的配置
Git 配置有三个层级，它们的优先级**从低到高**依次是：
1. **系统级配置** (`/etc/gitconfig`): 
	* 对系统上的所有用户和所有仓库有效，通用配置
	* 使用 `git config --system` 配置
2. **用户级配置** (`~/.gitconfig` 或 `~/.config/git/config`): 
	* 只针对当前用户
	* 使用 `git config --global` 配置
3. **仓库级配置** (`.git/config`): 
	* 仅对当前 Git 仓库有效
	* 使用 `git config --local` 配置
### 用户信息
安装完 Git 应该做的第一件事就是设置你的**用户名称**与**邮件地址**。
```shell
git config --global user.name "你的用户名"
git config --global user.email "你的邮箱"
```
* 使用 `--global` 选项后，只需要全局配置一次；针对特定项目配置，无需 `--global` 选项。
### 文本编辑器
将 `emacs` 设置为 Git 的默认文本编辑器
```shell
git config --global core.editor emacs
```
将 `VS Code` 设置为 Git 的默认文本编辑器
```shell
git config --global core.editor "code --wait"
```
### 检查配置信息
`git config --list` 命令会列出当前 Git 配置的所有项，包括全局和本地配置。
```shell
$ git config --list
credential.helper=osxkeychain     # 使用 macOS Keychain 管理 Git 凭证
init.defaultbranch=main           # 初始化 Git 仓库时，默认主分支为 'main'
user.name=joeljhou                # Git 提交时使用的用户名
user.email=joeljhou336@gmail.com  # Git 提交时使用的邮箱地址
core.ignorecase=false             # 文件名区分大小写，默认值 false
```
### 获取帮助
若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：
```shell
$ git help <verb> 
$ git <verb> --help 
$ man git-<verb>
```
例如，要想获得 config 命令的手册，执行
```shell
$ git help config
```
## Git 基础（命令篇）
### 配置与帮助
#### `git config`:  Git配置
用于设置 Git 的配置变量，如用户名、邮箱、编辑器等
```shell
git config --global user.name "你的用户名"
git config --global user.email "你的邮箱"
```
#### `git help`: 帮助文档
用于显示 Git 命令的帮助文档
```shell
# 帮助信息
git help
# 命令指南
# 查看 'git help <命令>' 以了解特定子命令的详细信息
git help -a
# 概念指南
# 查看 'git help <概念>' 以获取系统概述。
git help -g
```
### 获取 Git 仓库
#### `git init`：初始化仓库
用于在现有目录中初始化一个新的 Git 仓库
```shell
$ git init
```
#### `git clone`：克隆远程仓库
用于从远程仓库创建一个 Git 仓库的拷贝
```shell
git clone <repository-url>
```
### 记录每次更新到仓库
#### `git add`：跟踪文件
用于将文件添加到暂存区，准备进行提交
```shell
# 添加文件/夹，多个使用“空格”隔开
git add <file>...
# 添加所有文件（包括新建、修改、删除）
git add .
```
注意：运行了`git add`之后又作了修订的文件，需要重新运行`git add` 把最新版本重新暂存起来。
#### `.gitignore`：忽略文件
 ，格式规范如下：
* **空行和以 `#` 开头的行**：表示注释，会被 Git 忽略。
* **使用 glob 模式匹配文件路径**，类似简化版的正则表达式：
	* `*`：匹配任意数量的任意字符
	*  `?`：匹配单个任意字符
	* `[abc]`：匹配方括号中列出的任意一个字符
	* `[0-9]`：匹配指定范围内的字符（0~9）
	*  `**`：匹配任意中间路径，比如 `a/**/z` 可匹配 `a/z`、`a/b/z`、`a/b/c/z` 等
* **特殊前缀符号说明**
	*  `/` 开头：表示从仓库根目录开始匹配
	* `/` 结尾：表示匹配目录
	* `!` 开头：表示“取反”，即要忽略指定模式以外的文件或目录
	**实际示例解析**
```shell
# 忽略所有 .a 文件
*.a
# 但要保留 lib.a（即使上面忽略了 .a 文件）
!lib.a
# 只忽略仓库根目录下的 TODO 文件
/TODO
# 忽略 build/ 目录及其中所有内容
build/
# 忽略 doc 目录下的 notes.txt 文件，但不忽略其他子目录下的 txt 文件
doc/*.txt
# 忽略 doc 目录下所有子目录中的 pdf 文件
doc/**/*.pdf
```

> GitHub 有一个收集了各种语言和框架的 `.gitignore` 模板库，可以从这里查找并使用符合自己项目的配置： 
👉 [https://github.com/github/gitignore](https://github.com/github/gitignore)
#### `git diff`：比较差异
比较 Git 各个区域（工作区、暂存区、提交记录）之间的差异
**📌 常用对比场景与命令**

| 命令                             | 对比范围                                                   |
| ------------------------------ | ------------------------------------------------------ |
| `git diff`                     | 🧩 工作区 vs 📦 暂存区                                       |
| `git diff --cached`            | 📦 暂存区 vs 最新提交（HEAD）                                   |
| `git diff --staged`            | 📌 同上                                                  |
| `git diff HEAD`                | 🧩 工作区（含暂存+未暂存） vs HEAD                                |
| `git diff <commit>`            | 🕓 指定提交 vs 当前工作区                                       |
| `git diff <commit1> <commit2>` | 🕓 提交1 vs 提交2                                          |
| `git difftool`                 | 使用图形化工具查看差异，支持 `meld`、`vimdiff`、`Beyond` `Compare` 等工具 |
| `git difftool --tool-help`     | 查看系统支持哪些 Git Diff 插件                                   |
#### `git commit`：提交更新
```shell
# 提交当前已暂存（staged）的修改。
git commit -m "提交暂存区"
# 自动将已被 Git 跟踪的文件的修改添加到暂存区并提交
git commit -am "跳过使用暂存区域"
```
#### `git rm`：移除文件
```shell
# 从工作区移除文件
$ rm <file>
# 从工作区和暂存区移除文件（等同于rm <file> + git add <file>两个指令）
$ git rm <file>
# 仅从暂存区移除文件，保留工作区内容
$ git rm --cached <file>
```
**支持 Glob 模式**
允许使用通配符来匹配文件。
```shell
# 递归删除整个目录及其子目录中的所有文件。慎用！
git rm -r *
# 删除 `log/` 目录下的 `.log` 文件
# 如果没有反斜杠，Shell 会先将 `*.log` 展开成实际的文件列表
git rm log/\*.log
# 删除所有以 `~` 结尾的文件
# 反斜杠作用，避免Shell 将 `*~` 展开成所有符合该模式的文件，再传递给 `git rm`。
git rm \*~
# 递归删除 `docs` 目录下的 `.md` 文件
git rm -r 'docs/*.md'
```
#### `git mv`：移动文件
如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么。
```shell
$ git mv README.md README
$ git status             
On branch main
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	renamed:    README.md -> README
```
相当于运行了下面三条命令：
```shell
mv README.md README
git rm README.md
git add README
```
### 检查文件状态
Git 工作目录下的每一个文件都不外乎这两种状态：
1. **已跟踪文件**：
	* 即被版本控制的文件
	* 工作一段时间后，这些文件可能会处于以下几种状态：
		* **未修改**：文件内容自上次提交以来没有变化，保留在当前版本中。
		* **已修改**：文件的内容有变化，但这些修改还未被加入暂存区。
		* **已暂存**：文件修改后已经被添加到暂存区，准备在下次提交时记录这些变动。
2. **未跟踪文件**：
	* 未被版本控制，或忽略的文件
	* 通过`git add <filename>`可以将未跟踪文件添加到暂存区，纳入版本控制。
**文件的状态变化周期**
![文件的状态变化周期](http://img.geekyspace.cn/pictures/2025/20250502004429356.png)
#### `git status`：文件状态详情
用于查看工作目录和暂存区的文件状态：
1. **✅干净的工作目录：`nothing to commit, working tree clean`**
	* 没有任何改动，工作区和暂存区一致
2. **📦已暂存的更改：`Changes to be committed`**
	* `new file:` 新增文件并已暂存
	* `modified:` 文件内容有修改并已暂存
	* `deleted:` 文件已被删除并暂存
3. **📝有文件被修改但未暂存：`Changes not staged for commit`**
	- `modified:` 文件被修改但未暂存
	* `deleted:` 文件被删除但未暂存
4. **🆕未追踪文件：`Untracked files`**
	* 文件是新添加的，但 Git 尚未跟踪（未使用 `git add`）
#### `git status -s`：状态简览
相比 `git status` 的详细输出，`git status -s`（或 `--short`）提供更**紧凑**的状态摘要，适合快速查看当前变更。
**示例：**
```shell
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
**速记：**
* 左边代表已暂存，右边代表已修改；
*  `M`是修改，`A`是添加，`??`是未追踪。
### 查看提交历史
#### `git log`：查看提交历史
```shell
$ git log
commit 🔐SHA-1 (HEAD -> master)
Author: 🧑‍💻作者 <📮邮箱>
Date:   2025-05-20 00:00:00 +0800

    ✨ 提交说明（如：优化首页加载速度）
```
#### `git log`：常用选项
![[Pro Git 中文版 第2版 2.1.1.pdf#page=41&rect=46,253,567,486|Pro Git 中文版 第2版 2.1.1, p.31]]
✅ **`-p`：显示每次提交的差异（diff）**
```shell
$ git log -p

commit a1b2c3d4
Author: Alice <alice@gmail.com>
Date:   Fri May 9 17:22:17 2025 +0800

    修改欢迎语

diff --git a/main.js b/main.js
--- a/main.js
+++ b/main.js
@@ -1,4 +1,4 @@
-console.log("Hello, world!");
+console.log("Welcome to my site!");
```
✅ **`--stat`：显示每次提交涉及的文件及统计信息**
```shell
$ git log --stat

commit a1b2c3d4
Author: Alice <alice@example.com>
Date:   Fri May 9 17:22:17 2025 +0800

    修改欢迎语

 main.js | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
```
✅ **`--shortstat`：仅显示修改统计汇总**
```shell
$ git log --shortstat

commit a1b2c3d4
Author: Alice <alice@example.com>
Date:   Fri May 9 17:22:17 2025 +0800

    修改欢迎语

 1 file changed, 1 insertion(+), 1 deletion(-)
```
✅ **`--name-only`：仅显示受影响文件**
```shell
$ git log --name-only

Acommit a1b2c3d4
Author: Alice <alice@example.com>
Date:   Fri May 9 17:22:17 2025 +0800

    修改欢迎语

main.js
```
✅ **`--abbrev-commit`：使用简短提交 ID**
```shell
$ git log --abbrev-commit

commit a1b2c3d
Author: Alice <alice@example.com>
Date:   Fri May 9 17:22:17 2025 +0800

    修改欢迎语
```
✅ **`--relative-date`：以相对时间显示日期**
```shell
$ git log --relative-date

commit a1b2c3d4
Author: Alice <alice@example.com>
Date:   2 hours ago

    修改欢迎语
```
✅ **`--graph`：图形化查看分支历史**
* 可以与`oneline`或`format`结合使用
```shell
$ git log --graph --oneline

* a1b2c3d4 修改欢迎语
* | f1e2d3c4 修复按钮样式
| * 2b3c4d5e 添加用户登录功能
|/
* 3a4b5c6d 初始化项目
```
✅ **`--decorate`：显示分支名和标签**
```shell
$ git log --oneline --decorate --graph --all
```
✅ **`--pretty`：自定义格式输出**
```shell
$ git log --pretty=oneline
$ git log --pretty=format:"%h - %an, %ad : %s" --date=local

* a1b2c3d4 - Alice, 2025年5月9日 17:22 : 修改欢迎语
* | f1e2d3c4 - Bob, 2025年5月8日 14:45 : 修复按钮样式
| * 2b3c4d5e - Carol, 2025年5月7日 12:30 : 添加用户登录功能
|/
* 3a4b5c6d - Alice, 2025年5月5日 09:12 : 初始化项目
```
![[Pro Git 中文版 第2版 2.1.1.pdf#page=40&rect=44,285,570,629|Pro Git 中文版 第2版 2.1.1, p.31]]
#### `git log`：限制输出长度
![[Pro Git 中文版 第2版 2.1.1.pdf#page=42&rect=44,279,562,460|Pro Git 中文版 第2版 2.1.1, p.38]]
✅ **限制输出条数**
```shell
# 查看最近 5 次提交
git log -2
```
✅ **限制输出时间**
* 🕒 时间格式参考：
	* 绝对时间：如 `2025-05-10`、`2025-05-10 14:00`
	* 相对时间：如 `2 years 1 day 3 minutes ago`、`last monday`、`1 week ago`
```shell
# 查看指定时间之后的提交（since/after 等价）
git log --since=2.weeks
git log --after="2025-05-01"

# 查看指定时间之前的提交（until/before 等价）
git log --until=2.weeks
git log --before="2025-05-01"
```
✅ **按作者/提交者筛选**
```shell
# 查看 Alice 提交的记录
git log --author="Alice"

# 查看由 Carol 提交（即由她运行 git commit）的记录
git log --committer="Carol"
```
✅ **按提交说明模糊筛选**
```shell
# 显示所有包含“欢迎”的提交信息
git log --grep="欢迎"
```
✅ **多条件组合筛选：使用 `--all-match`（AND 逻辑）**
```shell
# 提交者是 Alice 且说明中包含“欢迎”
git log --author="Alice" --grep="欢迎" --all-match

# 同时包含多个关键词（必须都命中）
git log --grep="欢迎" --grep="登录" --all-match
```
✅ **精确追踪代码内容变动：使用 `-S`**
```shell
# 查找添加或移除了字符串 "Welcome" 的提交
git log -S"Welcome"

# 结合 -p 查看修改细节
git log -S"Welcome" -p
```
### 撤消操作
#### `git commit --amend`：修正提交
```shell
# 第二次提交替代第一次提交的结果
git commit --amend -m "修正提交"
```
#### `git restore`：撤销文件
```shell
# 取消暂存的文件
git restore --staged <file>...
# 撤消对文件的修改/丢弃工作目录中的更改（慎用）
git restore <file>...
```
### 远程仓库使用
#### `git remote`：管理远程仓库
```shell
# 列出远程仓库简写名（shortname）
$ git remote
origin
```
* `origin` 是默认的远程仓库名称
✅ **查看远程仓库地址（-v）**
```shell
# 查看详细的 URL 信息
$ git remote -v
gk	    https://github.com/joeljhou/geekyspace.git (fetch)
gk	    https://github.com/joeljhou/geekyspace.git (push)
origin	git@github.com:joeljhou/geekyspace.git (fetch)
origin	git@github.com:joeljhou/geekyspace.git (push)
```
✅ **查看远程仓库详情（show）**
* 语法：`git remote show [remote-name]`
* 显示远程仓库的完整配置信息
	* `tracked`: 本地已有对应的远程分支引用；
	* `new`: 是远程新增的分支，尚未在本地存在；
	* `stale`: 远程已删除，本地仍保留，可用 `git remote prune` 清除。
```shell
$ git remote show origin
* remote origin
  Fetch URL: git@github.com:joeljhou/geekyspace.git
  Push  URL: git@github.com:joeljhou/geekyspace.git
  HEAD branch: master
  Remote branches:
    master   tracked
    dev      new (next fetch will store in remotes/origin)
    old      stale (use 'git remote prune' to remove)
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
```
✅ **添加远程仓库（add）**
* 语法：`git remote add <shortname> <url> `
```shell
git remote add gk https://github.com/joeljhou/geekyspace.git
```
添加后可在后续命令中使用简写名 `gk` 来代替完整 URL。
✅ **重命名远程仓库（rename）**
```shell
git remote rename gk gkspace
```
✅ **移除远程仓库（rm）**
```shell
git remote rm gkspace
```
#### `git fetch`：获取远程更新（不自动合并）
语法：`git fetch [remote-name]`
```
git fetch origin
```
执行命令后，你将会拥有远程仓库中所有分支的引用，需手动合并。
#### `git pull`：拉取远程更新	
语法：`git pull [remote-name] [branch-name]`
```shell
git pull origin main
# 简写形式
git pull
```
它等同于执行一次 `fetch` 然后再 `merge`。
#### `git push`：推送到远程仓库
语法：`git push [remote-name] [branch-name]`
```shell
git push origin master
```
 ⚠️ 注意事项：
 * 你必须对目标远程仓库拥有**写入权限**；
 * 如果这是该分支**首次推送**，Git 会在远程创建对应分支；
 * 如果远程已有更新，而你本地没有同步，推送会被**拒绝**，必须先拉取并合并远程的最新更改。
### 打标签
#### `git tag`：创建和管理标签
✅ **列出标签**
* 标签默认以**字母顺序**列出，但顺序没有实际意义。
```shell
$ git tag 
v0.1
v1.3
```
✅ **模糊匹配标签名（-l）**
```shell
$ git tag -l 'v1.8.5*'
v1.8.5
v1.8.5-rc0
v1.8.5.1
```
✅ **查看标签**
* 语法：`git show <tagname>`
```shell
# 显示标签指向的提交详情
$ git show v1.0
```
✅ **创建标签（-a）**
Git 支持两种类型的标签：
1. 🪶 轻量标签（`lightweight`）：临时标记，不含元信息，仅指向某次提交。
	* 语法：`git tag <tagname>`
2. 📝 **附注标签**（`annotated`）：独立对象，含作者、时间、说明，可签名。**推荐**用于发布版本。
	* 语法：`git tag -a <tagname> -m "message"` 
* 🕰️ 历史提交打标签
	* 语法：`git tag -a <tagname> <commit-id> -m "message"`
```shell
# 1.轻量标签
$ git tag v1.0-lw
# 2.附注标签
$ git tag -a v1.0 -m "发布版本 v1.0"
# 3.历史提交打标签
$ git log --pretty=oneline. # 查找历史提交 ID
$ git tag -a v0.9 abc1234 -m "发布 v0.9"
```
✅ **共享（推送）标签**
* `git push` 不会自动推送标签到远程仓库。你需要手动推送标签。
```shell
# 推送单个/多个标签
git push origin [tag-name]...
# 推送所有本地标签
git push origin --tags
```
✅ **删除标签（-d）**
* 本地标签语法：`git tag -d <tagname>` 
*  远程标签语法：`git push <remote-name> :refs/tags/<tagname>`
	* `:` 左侧为空，表示“推送空引用”
	* `refs/tags/<tag-name>` 是远程标签的完整引用路径，可简写为`<tag-name>`。
```shell
# 删除本地标签
$ git tag -d v1.0
Deleted tag 'v1.0' (was abc1234)

# 删除远程标签
$ git push origin :v1.0
To origin
 - [deleted]         v1.0
```
✅ **检出标签**
* 即在特定的标签上创建一个新分支
* 语法：`git checkout -b <new-branchname> <tagname>`
* 新版本推荐：`git switch -c <new-branchname> <tagname>`
```shell
# 基于 v2.0.0 标签创建一个可编辑的新分支"version2"
$ git checkout -b version2 v2.0.0
Switched to a new branch 'version2'
```
### Git 别名
**常用命令设置别名**
```shell
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```
**自定义实用别名**
* **取消暂存文件**
```shell
# 旧版本
git config --global alias.unstage 'reset HEAD --'
# 新版本
git config --global alias.unstage 'restore --staged'
# 用法：git unstage fileA 等同于 git reset HEAD -- fileA
```
* **查看最后一次提交**
```shell
git config --global alias.last 'log -1 HEAD'
# 用法：git last 显示最近一次提交信息
```
**运行外部命令**
如果你想让别名执行外部命令而不是 Git 子命令，可在别名前加 `!`：
```shell
git config --global alias.visual '!gitk'
# 用法：git visual 启动 gitk 图形界面
```
## Git 分支
Git 的分支模型极其轻量，鼓励在工作流中频繁**创建**与**合并**分支，这是它脱颖而出的“<u>必杀技</u>”特性。
假设你有一个项目目录结构如下：
```shell
project/
├── README.md
├── src/
│   └── main.java
└── LICENSE
```
在提交时：
* `README.md`、`main.java`、`LICENSE` 的内容会被保存成 `blob` 对象。
*  `src/` 目录会被保存成一个 `tree` 对象，它引用了 `main.java` 的 `blob`。
* `project/` 根目录也会被保存成一个 `tree` 对象，它引用了：
	* `README.md` 的 `blob`
	* `LICENSE` 的 `blob`
	* `src/` 这个子目录对应的 `tree`。
Git 分支本质上是一个指向最新提交的可变指针，每次提交都会自动向前移动。
![[Pro Git 中文版 第2版 2.1.1.pdf#page=58&rect=38,481,574,742|Pro Git 中文版 第2版 2.1.1, p.51]]
#### `git branch`：新建分支
✅ **列出分支**
* 语法：`git branch`
```shell
# 列出所有分支
$ git branch
# 查看已合并的分支（自行选择删除）
$ git branch --merged
# 查看未合并的分支（自行选择合并）
$ git branch --no-merged
```
✅ **新建分支**
* 语法：`git branch <branch-name>`
```shell
$ git branch hotfix
```
✅ **新建并切换分支（-b）**
* 语法：`git branch -b <branch-name>`
* 相当于`git branch`和`git checkout`两条命令的简写。
```shell
$ git checkout -b iss53 
Switched to a new branch "iss53"

# 查看各个分支当前所指的对象（理解！！！）
$ git log --oneline --decorate --graph --all
* f30ab (HEAD -> iss53) 修复数据处理逻辑
* 34ac2 (main) 增加用户登录功能
| * ab28c (hotfix) 修复线上bug [issue 53]
|/  
* 98ca9 第一次代码提交
* ed596 初始化工程
```
其中`HEAD` 指向当前所在的分支。
✅ **删除分支（-d）**
* 语法：`git branch -d <branch-name>`
```shell
$ git branch -d hotfix
# 强制删除（-D）
$ git branch - testing
```
#### `git checkout`：分支切换

| 功能用途           | 命令格式                              | 推荐替代命令                                 |
| -------------- | --------------------------------- | -------------------------------------- |
| 切换分支           | `git checkout <branch>`           | `git switch <branch>`                  |
| 新建并切换分支        | `git checkout -b <branch>`        | `git switch -c <branch>`               |
| 检出旧版本（游离 HEAD） | `git checkout <commit>`           | ❌（无替代，继续使用）                            |
| 撤销文件改动         | `git checkout -- <file>`          | `git restore <file>`                   |
| 从其他分支检出文件      | `git checkout <branch> -- <file>` | `git restore --source <branch> <file>` |
#### `git switch`：分支切换（推荐）
语法：`git switch <branch-name>`
```shell
$ git switch testing
```
这样 `HEAD` 就指向 testing 分支了。
#### `git merge`：合并分支
语法：`git merge <branch-name>`
```shell
$ git switch main

# 遇到冲突时的分支合并
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
# 查看冲突文件
$ cat index.html
<<<<<<< HEAD
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> feature
```
合并分支的三种场景：
1. **快进合并（Fast-forward Merge）**
	* 目标分支没有新的提交，且在时间线上落后于要合并的分支。
	* 本质是直接把指针“**快进**（fast-forward）”到目标分支。
 2. **三方合并（Three-way Merge）**
	 * 目标分支和要合并分支各自有新的提交，分支点之后有分叉。
	 * 本质是基于分叉节点，以及两个分支的末端所指的快照，做一个简单的**三方合并**。形成一个新的提交。
 3. **冲突合并（Merge Conflict）**
	 * 在三方合并过程中，如果两个分支对同一文件的同一部分做了不兼容的修改，Git 无法自动合并。
	 * 需要人工介入，查看冲突内容，手动编辑解决冲突后，再完成合并提交。
#### `git rebase`：变基（整理提交历史）



#### `git stash`：临时保存工作进度
